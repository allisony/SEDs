import numpy as np
import matplotlib.pyplot as plt
import glob
import astropy.io.fits as fits
import os
from scipy.io.idl import readsav
from astropy.table import Table
from astropy.io import ascii
import astropy.units as u
import instruments as inst #pl's istrument code, might just make a function here
from astropy.time import Time
from astropy.units import cds
cds.enable()

"""
v1 20190418
Script to make Mega-Muscles spectra. Will develop over time.

objectives for this version
output: a file with everything that MUSCLES did i.e.
'WAVELENGTH' 
'WAVELENGTH0' = wavelength bin edges
'WAVELENGTH1'
'FLUX'
'ERROR'
'EXPTIME' exptime of that bit of spectrum
'DQ',
'EXPSTART' exposure dates, mjd
'EXPEND',
'INSTRUMENT', bitwise- could we do this with words or is it what hlsp requires?
'NORMFAC',
'BOLOFLUX' =flux normalised to bolometric flux
'BOLOERR'




"""


#totals = [w_full, f_full, e_full, dq_full, n_full,i_full]
#additions =[w, f, e, dq, n, instrument]

def add_spec(totals, additions):
    """running combinations of wavelength, flux, error, data quality flags, normalisation and instrument"""
    totals =  np.concatenate((totals, additions), axis=1)
    return totals

def sort_totals(totals):
    """sorts totals array by wavelength"""
    arr1inds = totals[2].argsort()
    totals = [t[arr1inds] for t in totals]
    #for t in totals:
     #   t = t[arr1inds]
    return totals
    
def totals_setup():
    """set up arrays to keep running totals of data"""
    names = ['WAVELENGTH','WAVELENGTH0', 'WAVELENGTH1','FLUX','ERROR','EXPTIME',
             'DQ','EXPSTART','EXPEND','INSTRUMENT','NORMFAC']#,'BOLOFLUX' ,'BOLOERR'] #bolos are done when spectrum is compleate
    totals = []
    i = 0
    while i < len(names):
        totals.append([])
        i += 1
    totals = np.array(totals, dtype = float)
    return names, totals

def make_section(totals, data, mask =[], normfac=1.0, clip=[], plot=True):
    """
    runs all the functions needed to add a section to the spectrum
    """
    w, f, additions = build_additions(data, mask=mask, normfac=normfac, clip=clip)
    if plot==True:
        plot_spectrum(w,f)
    totals = add_spec(totals, additions)
    w_start, w_end = w[0],w[-1]
    return w_start, w_end, totals

def build_additions(col, mask=[],  normfac=1.0, clip=[]):
    """
    makes the "addition" array if a mask is applied. "col" is one of the collection dicts generated by the read functions
    """
    if len(mask) > 0:
        if len(clip) > 1: #clip if there are options to clip
            w0, w1, w, f, e, dq, exptime = col['w0'][mask][clip[0]:clip[1]], col['w1'][mask][clip[0]:clip[1]],col['w'][mask][clip[0]:clip[1]],col['f'][mask][clip[0]:clip[1]],col['e'][mask][clip[0]:clip[1]],col['dq'][mask][clip[0]:clip[1]],col['exptime'][mask][clip[0]:clip[1]]
        else:
            w0, w1, w, f, e, dq, exptime = col['w0'][mask], col['w1'][mask],col['w'][mask],col['f'][mask],col['e'][mask],col['dq'][mask],col['exptime'][mask]
    else:
        if len(clip) > 1: #clip if there are options to clip
            w0, w1, w, f, e, dq, exptime = col['w0'][clip[0]:clip[1]], col['w1'][clip[0]:clip[1]],col['w'][clip[0]:clip[1]],col['f'][clip[0]:clip[1]],col['e'][clip[0]:clip[1]],col['dq'][clip[0]:clip[1]],col['exptime'][clip[0]:clip[1]]
        else:
            w0, w1, w, f, e, dq, exptime = col['w0'], col['w1'],col['w'],col['f'],col['e'],col['dq'],col['exptime']        
    f, e = f*normfac, e*normfac #spectrum scaling
    expstart = np.full(len(w),col['expstart'], dtype=float)
    expend = np.full(len(w),col['expend'],dtype=float)
    instrument = np.full(len(w),col['instrument'],dtype=int)
    normfac = np.full(len(w),normfac,dtype=float)
    additions = [w, w0, w1, f, e, exptime,dq, expstart, expend, instrument, normfac]
    return w, f, additions
    
    
def plot_spectrum(w, f):
    """plots a spectrum section"""
    plt.step(w,f)

def euv_estimator(lya, distance, star='', save=False, plot=False):
    """
    Calculating the EUV fluxes using the relationships of Linsky + 14 (https://ui.adsabs.harvard.edu/abs/2014ApJ...780...61L/abstract)

    log[F(delta lambda) /F(lya)]=

    10–20 nm (stars) 	 	−0.491 	 
    20–30 nm (stars) 	 	−0.548 	 
    30–40 nm (stars) 		−0.602 	 
    40–50 nm (models) 	  	  	−2.294+0.258 log[f (Lyα)]
    50–60 nm (models) 	  	  	−2.098+0.572 log[f (Lyα)]
    60–70 nm (models) 	  	  	−1.920+0.240 log[f (Lyα)]
    70–80 nm (models) 	  	  	−1.894+0.518 log[f (Lyα)]
    80–91.2 nm (models) 	  	  	−1.811+0.764 log[f (Lyα)]
    91.2–117 nm (models) 	  	  	−1.004+0.065 log[f (Lyα)]

    """
    distance_conversion = ((1*u.au.to(u.m))/(distance*u.pc.to(u.m)))**2

    lya_1au = lya / distance_conversion

    w1 = np.array([100,200,300,400,500,600,700,800,912], dtype=float) #A
    w2 = np.array([200,300,400,500,600,700,800,912,1170], dtype=float)
    bandwidth = w2-w1

    a = np.array([-0.491,-0.548,-0.602,-2.294,-2.098,-1.920,-1.894,-1.811,-1.004], dtype=float)
    b = np.array([ 0.,    0.,    0.,    0.258, 0.572, 0.240, 0.518, 0.764, 0.065], dtype=float)

    #log(f/lya) = a + b *log(lya)
    f = a + b*np.log10(lya_1au)

   # print('Total EUV=',np.sum(f))
    f = (lya_1au * 10**f)/bandwidth

    f *= distance_conversion

    #extrapolate onto 1A grid
    wav = np.arange((w1[0])+0.5, (w2[-1])+0.5, 1.0)
    flux = []
    for w1i, w2i, fi in zip(w1, w2,f):
        for wi in wav:
            if wi > w1i and wi < w2i :
                flux.append(fi)

    if save == True:
        data = Table([wav*u.AA,  flux*u.erg/u.s/u.cm**2], names=['WAVELENGTH', 'FLUX'])
        ascii.write(data, star+'_1Aeuv_estimate.ecsv', delimiter=',', format='ecsv', overwrite=True)

    if plot == True:
        plt.figure(star+'_EUV', figsize=(8,6))
        plt.subplots_adjust(top=0.99, right=0.99)
        plt.plot(wav, flux)
        plt.xlabel('Wavelength (\AA)', size=20)
        plt.ylabel('Flux (erg s$^{-1}$\AA$^{-1}$cm$^{-2}$)', size=20)
        plt.yscale('log')
        plt.show()
    
    return(wav, np.array(flux)) 

def wavelength_edges(w):
    """
    Calulates w0 and w1
    """
    diff = np.diff(w)
    diff = np.concatenate((np.array([diff[0]]), diff)) #adds an extravalue to make len(diff) = len(w)
    w0 = w - diff/2.
    w1 = w + diff/2.
    return w0, w1

def dict_builder(w0, w1, w, f, e, dq, exptime, expstart, expend, instrument_code): 
    """
    puts all the bits for each instrument into a dictionary. 
    w0, w1, w, f, e, dq, exptime are arrays of the same length
    expstart, expend are floats
    instrument_code is an integer
    """
    collection = {'w0':w0, 'w1':w1, 'w':w, 'f':f, 'e':e, 'dq':dq, 'exptime':exptime, 'expstart':expstart, 'expend':expend, 'instrument': instrument_code}
    return collection

def read_idl(filepath):
    """
    Extracts data from KF's IDL files
    """
    data = readsav(filepath)
    w, f, e, exptime = data['wave'], data['flux'], data['err'], data['exptime']
    dq = np.zeros(len(w)) #consult with kf on this
    w0, w1 = wavelength_edges(w)
    instrument_list = np.unique(data['grating'])
    instruments = np.array([('hst_cos_'+str(i)[2:-1].lower()) for i in instrument_list])
    instrument_code = np.sum([inst.getinsti(i) for i in instrument_list])
    expstart, expend = 0, 0 #not in idl, placeholder.
    idl_collection = dict_builder(w0, w1, w, f, e, dq, exptime, expstart, expend, instrument_code)
    return idl_collection

def read_stis_x1d(filepath):
    """
    Extracts data from a hst x1d file
    """
    hdul = fits.open(filepath)
    data = hdul[1].data[0]
    w, f, e, dq = data['WAVELENGTH'], data['FLUX'], data['ERROR'], data['DQ']
    w0, w1 = wavelength_edges(w)
    hdr = hdul[0].header
    exptime = np.full(len(w), hdr['TEXPTIME'])
    expstart, expend = hdr['TEXPSTRT'], hdr['TEXPEND']
    instrument_name = hdr['TELESCOP']+'_sts_'+hdr['OPT_ELEM']  #nb STIS=sts in Pl code 
    instrument_code = inst.getinsti(instrument_name.lower())
    stis_x1d_collection = dict_builder(w0, w1, w, f, e, dq, exptime, expstart, expend, instrument_code)
    hdul.close()
    return stis_x1d_collection

def read_ecsv(filepath):
    """
    reads an escv with a coadded spectrum. Not much in these yet, need to improve.
    """
    data = Table.read(filepath)#
    w, f, e, dq = data['WAVELENGTH'], data['FLUX'], data['ERROR'], data['DQ']
    w0, w1 = wavelength_edges(w)
    #needs everything else!
    ecsv_collection =  dict_builder(w0, w1, w, f, e, dq, np.zeros(len(w)), 0.,0, 0)
    return ecsv_collection
    
def read_xmm(filepath):
    """
    collects data from CS's xmm outputs and for the apec models
    """
    hdul = fits.open(filepath)
    #spectrum
    data = hdul[1].data
    w, f, e = data['Wave'], data['CFlux'], data['CFLux_Err']
    w0, w1 = w - (data['bin_width']/2), w+(data['bin_width']/2)
    hdr = hdul[0].header
    exptime = np.full(len(w), hdr['HIERARCH pn_DURATION'])
    expstart = Time(hdr['HIERARCH pn_DATE-OBS']).mjd
    expend = Time(hdr['HIERARCH pn_DATE-END']).mjd
    instrument_list = ['xmm_epc_multi','xmm_epc_pn---']
    instrument_code = np.sum([inst.getinsti(i) for i in instrument_list])
    xmm_collection = dict_builder(w0, w1, w, f, e, np.zeros(len(w)),exptime, expstart, expend, instrument_code)
    #model
    data = hdul[2].data
    w, f = data['Wave'], data['Flux']
    w0, w1 = w - (data['bin_width']/2), w+(data['bin_width']/2)
   # hdr = hdul[0].header
    instrument_code = inst.getinsti('mod_apc_-----')
    exptime = np.full(len(w), hdr['HIERARCH pn_DURATION'])
    apec_collection = dict_builder(w0, w1, w, f, np.zeros(len(w)), np.zeros(len(w)),exptime, expstart, expend, instrument_code)
    hdul.close()
    return xmm_collection, apec_collection

def read_lyamod(filepath):
    """
    gather information from a lya model
    """
    lya = Table.read(filepath, format='ascii')
    w, f = lya['WAVELENGTH'], lya['FLUX']
    w0, w1 = wavelength_edges(w)
    instrument_code = inst.getinsti('mod_lya_young')
    lya_collection = dict_builder(w0,w1,w,f, np.zeros(len(w)), np.zeros(len(w)), np.zeros(len(w)), 0., 0., instrument_code)
    return lya_collection

def read_scaled_phoenix(filepath):
    """
    gather information from a pre-scaled phoenix model
    """
    data = Table.read(filepath)
    w, f = data['WAVELENGTH'], data['FLUX']
    w0, w1 = wavelength_edges(w)
    instrument_code = inst.getinsti('mod_phx_-----')
    phx_collection = dict_builder(w0,w1,w,f, np.zeros(len(w)), np.zeros(len(w)), np.zeros(len(w)), 0., 0., instrument_code)
    return phx_collection
    
def read_phoenix(filepath, wavepath):
    """
    gather information from a phoenix model. Note that flux and wavelegth are in different files
    """
    w = fits.getdata(wavepath, 0)
    f = fits.getdata(filepath)
    w0, w1 = wavelength_edges(w)
    instrument_code = inst.getinsti('mod_phx_-----')
    phx_collection = dict_builder(w0,w1,w,f, np.zeros(len(w)), np.zeros(len(w)), np.zeros(len(w)), 0., 0., instrument_code)
    return phx_collection
    
def read_stis_ccd(filepath):
    """
    collects data for a STIS ccd observation
    """
    data = fits.getdata(filepath)[0]
    hdr = fits.getheader(filepath,0)
    w, f, e, dq = data['WAVELENGTH'], data['FLUX'], data['ERROR'], data['DQ']
    w0, w1 = wavelength_edges(w)
    exptime = np.full(len(w), hdr['TEXPTIME'])
    expstart, expend = hdr['TEXPSTRT'], hdr['TEXPEND']
    instrument_name = hdr['TELESCOP']+'_sts_'+hdr['OPT_ELEM']  #nb STIS=sts in Pl code 
    instrument_code = inst.getinsti(instrument_name.lower())
    stis_ccd_collection = dict_builder(w0, w1, w, f, e, dq, exptime, expstart, expend, instrument_code)
    return stis_ccd_collection

def make_euv(lya, distance):
    """
    collects the bits for an euv estimation
    """
    w, f = euv_estimator(lya, distance)
    w0, w1 = wavelength_edges(w)
    e, dq, exptime = np.zeros(len(w)), np.zeros(len(w)), np.zeros(len(w))
    expstart, expend = 0., 0.
    instrument_code = inst.getinsti('mod_euv_young')
    euv_collection = dict_builder(w0, w1, w, f, e, dq, exptime, expstart, expend, instrument_code)
    return euv_collection
                                                                
def save_to_ecsv(totals, names, star, version, save_path = ''):
    """
    saves the completed spectrum to an ecsv file. No bolflux for now.
    names = ['WAVELENGTH','WAVELENGTH0', 'WAVELENGTH1','FLUX','ERROR','EXPTIME',
             'DQ','EXPSTART','EXPEND','INSTRUMENT','NORMFAC']#,'BOLOFLUX' ,'BOLOERR']
    """
    data = Table([totals[0]*u.AA, totals[1]*u.AA, totals[2]*u.AA, 
                  totals[3]*u.erg/u.s/u.AA/u.cm**2, totals[4]*u.erg/u.s/u.AA/u.cm**2,
                  totals[5]*u.s, totals[6], totals[7]*cds.MJD, totals[8]*cds.MJD,
                  totals[9], totals[10]],
                names=names)
    ascii.write(data, star+'_sed_var_res_'+version+'.ecsv', format = 'ecsv', overwrite=True)
    
    #data = Table([w_full*u.AA, f_full*u.erg/u.cm**2/u.s/u.AA, e_full*u.erg/u.cm**2/u.s/u.AA, n_full], names = ['WAVELENGTH', 'FLUX', 'ERROR', 'NORMFAC'] )
#ascii.write(data, 'gj674_data+models_v1.ecsv', delimiter=',', format='ecsv', overwrite=True)

    
"""
Information I need to provide for each spectrum:
-where to get the data
-how to extract it
-what range to plot
-what scaling to use

Information I need to extract:
-wavelength
-wavelength edges (for some)
-flux
-error
-dq
-exptime
-expstart
-expend
-instrument

Information I need to caculate:
-wavelength edges (for some)
-boloflux
-boloerror

"""

